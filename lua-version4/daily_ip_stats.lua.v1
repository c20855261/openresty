local redis = require "resty.redis"
local http = require "resty.http"
local cjson = require "cjson.safe"
local cfg = require "config"

-- alias 正確使用 ngx.escape_uri
local ngx_escape = ngx.escape_uri

-- 配置
local REDIS_HOST = cfg.redis_host or "127.0.0.1"
local REDIS_PORT = cfg.redis_port or 6379
local SECONDARY_REDIS_HOST = cfg.secondary_redis_host or ""
local SECONDARY_REDIS_PORT = cfg.secondary_redis_port or 6379
local WHITELIST_FILE = cfg.whitelist_file or "/opt/openresty/nginx/conf/conf.d/lua/whitelist.txt"
local DAILY_KEY_PREFIX = "daily:ipcounts:"
local DEFAULT_TOP = 50
local DATE_RANGE_DAYS = 14
local OPS_LOG_LIST = "ops_log"
local OPS_LOG_MAX = 100
local ADMIN_TOKEN = "" 
local BAN_TTL = cfg.ban_ttl or cfg.ban_time or 3600

---------------------------------------------------------------------
-- Redis Connect
---------------------------------------------------------------------
local function connect_redis(host, port)
    local red = redis:new()
    red:set_timeout(1000)
    local ok, err = red:connect(host or REDIS_HOST, port or REDIS_PORT)
    if not ok then return nil, err end
    return red, nil
end

local function try_redis_connect()
    return connect_redis(REDIS_HOST, REDIS_PORT)
end

local function try_secondary_redis()
    if not SECONDARY_REDIS_HOST or SECONDARY_REDIS_HOST == "" then
        return nil, "no secondary"
    end
    return connect_redis(SECONDARY_REDIS_HOST, SECONDARY_REDIS_PORT)
end

local function daily_key_for_date(date_str)
    return DAILY_KEY_PREFIX .. date_str
end

---------------------------------------------------------------------
-- Whitelist File Read/Write
---------------------------------------------------------------------
local function read_whitelist_from_file()
    local t = {}
    local f = io.open(WHITELIST_FILE, "r")
    if not f then return nil, "open_failed" end

    for line in f:lines() do
        local s = line:match("^%s*(.-)%s*$")
        if s ~= "" and not s:match("^#") then t[s] = true end
    end

    f:close()
    return t, "file"
end

local function write_whitelist_to_file(tbl)
    local f, err = io.open(WHITELIST_FILE, "w+")
    if not f then return nil, err end

    for ip, _ in pairs(tbl) do f:write(ip .. "\n") end
    f:close()
    return true, "file"
end

local function read_whitelist()
    local tbl, src = read_whitelist_from_file()
    if tbl then return tbl, src end

    -- fallback to redis
    local red = try_redis_connect()
    if not red then return {}, "none" end

    local res = red:smembers("whitelist:set")
    red:set_keepalive(10000,100)

    if not res then return {}, "none" end

    local out = {}
    for _, ip in ipairs(res) do out[ip] = true end
    return out, "redis"
end

local function write_whitelist(tbl)
    local ok = write_whitelist_to_file(tbl)
    if ok then return true, "file" end

    -- fallback to redis
    local red, err = try_redis_connect()
    if not red then return nil, "redis_connect_failed:" .. tostring(err) end

    red:del("whitelist:set")
    for ip,_ in pairs(tbl) do
        red:sadd("whitelist:set", ip)
    end
    red:set_keepalive(10000,100)
    return true, "redis"
end

---------------------------------------------------------------------
-- OPS LOG
---------------------------------------------------------------------
local function push_ops_log(entry)
    local s = cjson.encode(entry) or tostring(entry)

    local red = try_redis_connect()
    if red then
        pcall(function()
            red:lpush(OPS_LOG_LIST, s)
            red:ltrim(OPS_LOG_LIST, 0, OPS_LOG_MAX - 1)
            red:set_keepalive(10000, 100)
        end)
    end

    -- local fallback file
    pcall(function()
        local f = io.open("/tmp/daily_ip_stats_ops.log", "a+")
        if f then
            f:write(os.date("%Y-%m-%d %H:%M:%S") .. " " .. s .. "\n")
            f:close()
        end
    end)
end

---------------------------------------------------------------------
-- GEO Lookup (repo 中文 + fallback ip-api)
---------------------------------------------------------------------
local function get_geo_info_for_ip(red, ip)
    if not ip or ip == "" then return "unknown" end

    local cache_key = "geo:" .. ip

    -- redis cache
    if red then
        local ok, v = pcall(function() return red:get(cache_key) end)
        if ok and v and v ~= ngx.null then return v end
    end

    -- repo geo_mapping
    local okgeo, geomod = pcall(require, "geo_mapping")
    if okgeo and geomod and geomod.country_map then
        local httpc = http.new()
        httpc:set_timeout(1000)
        local ok, resp = pcall(function()
            return httpc:request_uri(
                "http://ip-api.com/json/" .. ngx_escape(ip) ..
                "?fields=status,country,regionName,city,countryCode",
                { method="GET", keepalive=false }
            )
        end)

        if ok and resp and resp.status == 200 then
            local j = cjson.decode(resp.body)
            if j and j.status == "success" then
                local country_en = j.country or ""
                local cn = geomod.country_map[country_en]
                         or geomod.country_map[country_en:lower()]
                local regionName = j.regionName or ""
                local city = j.city or ""
                local code = j.countryCode or ""

                local out
                if cn then
                    local parts = {cn}
                    if regionName ~= "" then table.insert(parts, regionName) end
                    if city ~= "" then table.insert(parts, city) end
                    if code ~= "" then table.insert(parts, "("..code..")") end
                    out = table.concat(parts, "，")
                else
                    local parts = {}
                    if country_en ~= "" then table.insert(parts, country_en) end
                    if regionName ~= "" then table.insert(parts, regionName) end
                    if city ~= "" then table.insert(parts, city) end
                    if code ~= "" then table.insert(parts, "("..code..")") end
                    out = table.concat(parts, ", ")
                end

                if red then pcall(function() red:setex(cache_key, 86400, out) end) end
                return out
            end
        end
    end

    -- fallback ip-api
    local httpc = http.new()
    httpc:set_timeout(1500)
    local ok, resp = pcall(function()
        return httpc:request_uri(
            "http://ip-api.com/json/" .. ngx_escape(ip) ..
            "?fields=status,country,regionName,city,countryCode",
            { method="GET", keepalive=false }
        )
    end)

    if ok and resp and resp.status == 200 then
        local j = cjson.decode(resp.body)
        if j and j.status == "success" then
            local parts = {}
            if j.country then table.insert(parts, j.country) end
            if j.regionName and j.regionName ~= "" then table.insert(parts, j.regionName) end
            if j.city and j.city ~= "" then table.insert(parts, j.city) end
            if j.countryCode then table.insert(parts, "("..j.countryCode..")") end
            local out = table.concat(parts, ", ")
            if red then pcall(function() red:setex(cache_key, 86400, out) end) end
            return out
        end
    end

    return "unknown"
end

---------------------------------------------------------------------
local function html_escape(s)
    if not s then return "" end
    return s:gsub("&","&amp;"):gsub("<","&lt;")
            :gsub(">","&gt;"):gsub('"',"&quot;")
            :gsub("'","&#39;")
end

---------------------------------------------------------------------
-- Parse Args
---------------------------------------------------------------------
local args = ngx.req.get_uri_args()
local date = args.date or os.date("%Y%m%d")
local top_n = tonumber(args.top) or DEFAULT_TOP
local fmt = (args.format or "html"):lower()
local msg = args.msg or ""

---------------------------------------------------------------------
-- POST handler (PRG redirect)
---------------------------------------------------------------------
if ngx.req.get_method() == "POST" then
    ngx.req.read_body()
    local post = ngx.req.get_post_args()

    local action = post.action or ""
    local ip = (post.ip or ""):match("^%s*(.-)%s*$")
    local provided_token = post.admin_token or ""

    if ADMIN_TOKEN ~= "" and provided_token ~= ADMIN_TOKEN then
        push_ops_log({action=action, ip=ip, result="invalid admin_token"})
        return ngx.redirect("/daily_ip_stats?date="..ngx_escape(date)
            .."&top="..tostring(top_n)
            .."&msg="..ngx_escape("invalid admin_token"))
    end

    if action == "" or ip == "" then
        push_ops_log({action=action, ip=ip, result="missing action or ip"})
        return ngx.redirect("/daily_ip_stats?date="..ngx_escape(date)
            .."&top="..tostring(top_n)
            .."&msg="..ngx_escape("missing action or ip"))
    end

    local result = { ok=false, action=action, ip=ip }

    if action == "add_whitelist" then
        local wl = read_whitelist()
        wl[ip] = true
        local ok, where = write_whitelist(wl)
        result.ok = ok
        result.msg = ok and ("added to whitelist ("..where..")")
                     or ("write failed: "..tostring(where))

    elseif action == "remove_whitelist" then
        local wl = read_whitelist()
        if wl[ip] then
            wl[ip] = nil
            local ok, where = write_whitelist(wl)
            result.ok = ok
            result.msg = ok and ("removed from whitelist ("..where..")")
                         or ("write failed: "..tostring(where))
        else
            result.msg = "ip not in whitelist"
        end

    elseif action == "add_blacklist" then
        local red, err = try_redis_connect()
        if not red then
            result.msg = "redis connect failed: "..tostring(err)
        else
            local ok, err = red:setex("ban:"..ip, BAN_TTL, "1")
            result.ok = ok
            result.msg = ok and "added to blacklist"
                         or ("redis setex failed: "..tostring(err))
            red:set_keepalive(10000,100)
        end

    elseif action == "remove_blacklist" then
        local total_deleted = 0

        local red = try_redis_connect()
        if red then
            local d = red:del("ban:"..ip)
            total_deleted = total_deleted + (tonumber(d) or 0)
            red:set_keepalive(10000,100)
        end

        if SECONDARY_REDIS_HOST ~= "" then
            local srd = try_secondary_redis()
            if srd then
                local d2 = srd:del("ban:"..ip)
                total_deleted = total_deleted + (tonumber(d2) or 0)
                srd:set_keepalive(10000,100)
            end
        end

        local chk = try_redis_connect()
        local still_exists = false
        if chk then
            local v = chk:get("ban:"..ip)
            still_exists = (v and v ~= ngx.null)
            chk:set_keepalive(10000,100)
        end

        if total_deleted > 0 and not still_exists then
            result.ok = true
            result.msg = "removed ban key(s): "..tostring(total_deleted)
        elseif total_deleted > 0 and still_exists then
            result.msg = "deleted from some nodes but still exists"
        else
            result.msg = "ban key not found"
        end

    else
        result.msg = "unknown action"
    end

    push_ops_log(result)

    return ngx.redirect("/daily_ip_stats?date="..ngx_escape(date)
        .."&top="..tostring(top_n)
        .."&msg="..ngx_escape(result.msg))
end

---------------------------------------------------------------------
-- GET handler
---------------------------------------------------------------------
local red, rerr = try_redis_connect()
if not red then
    if fmt == "json" then
        ngx.status = 500
        ngx.say(cjson.encode({error="redis connect failed", reason=rerr}))
    else
        ngx.header.content_type = "text/html"
        ngx.say("<h3>Redis connect failed: "..html_escape(tostring(rerr)).."</h3>")
    end
    return
end

local key = daily_key_for_date(date)
local res, err = red:zrevrange(key, 0, top_n - 1, "WITHSCORES")
if not res then
    red:set_keepalive(10000,100)
    ngx.status = 500
    ngx.say(cjson.encode({error="zrevrange failed", reason=err}))
    return
end

local rows = {}
for i = 1, #res, 2 do
    local member = res[i]
    local score = tonumber(res[i+1]) or 0
    local domain, ip = member:match("^([^:]+):(.+)$")
    if not domain then domain = "unknown"; ip = member end
    table.insert(rows, {domain=domain, ip=ip, count=score})
end

-- whitelist
local wl_tbl = read_whitelist()
local whitelist_list = {}
for ip,_ in pairs(wl_tbl) do table.insert(whitelist_list, ip) end

-- ops log
local ops = {}
do
    local lres = red:lrange(OPS_LOG_LIST, 0, 49)
    if lres then
        for _, raw in ipairs(lres) do
            local ok, parsed = pcall(cjson.decode, raw)
            table.insert(ops, ok and parsed or {raw=raw})
        end
    end
end

-- enrich region
for _, r in ipairs(rows) do
    r.region = get_geo_info_for_ip(red, r.ip) or "unknown"
end

red:set_keepalive(10000,100)

---------------------------------------------------------------------
-- JSON Output
---------------------------------------------------------------------
if fmt == "json" then
    ngx.header.content_type = "application/json; charset=utf-8"
    ngx.say(cjson.encode({
        date=date, top_n=top_n,
        rows=rows,
        whitelist=whitelist_list,
        ops=ops
    }))
    return
end

---------------------------------------------------------------------
-- HTML Output
---------------------------------------------------------------------
ngx.header.content_type = "text/html; charset=utf-8"

ngx.say("<!doctype html><html><head><meta charset='utf-8'><title>Daily IP Stats - "
    ..html_escape(date).."</title>")

ngx.say([[
<style>
body{font-family:Arial;margin:18px}
table{border-collapse:collapse;width:100%;margin-top:12px}
th,td{border:1px solid #ddd;padding:6px}
th{background:#f4f4f4}
.controls{display:flex;gap:12px;align-items:center;margin-bottom:12px}
.form-inline{display:inline-flex;gap:6px;align-items:center}
.notice{padding:8px;background:#f8f8f8;border:1px solid #eee;margin-top:8px}
.ops{margin-top:12px;border:1px solid #eee;padding:8px;background:#fafafa}
.small{font-size:0.9em;color:#666}
.msg-success { background:#e0ffe0;border-left:4px solid #4CAF50;padding:10px;margin:10px 0; }
.msg-error   { background:#ffe0e0;border-left:4px solid #f44336;padding:10px;margin:10px 0; }
</style>
</head><body>
]])

ngx.say("<h2>Daily IP Stats for " .. html_escape(date) ..
        " (top " .. tostring(top_n) .. ")</h2>")

-- 顯示操作訊息
if msg ~= "" then
    local cls = "msg-success"
    if msg:lower():match("fail") or msg:lower():match("error") or msg:lower():match("invalid") then
        cls = "msg-error"
    end
    ngx.say("<div class='"..cls.."'><strong>訊息：</strong> " .. html_escape(msg) .. "</div>")
end

---------------------------------------------------------------------
-- Date selector
---------------------------------------------------------------------
ngx.say("<div class='controls'><form id='dateForm' class='form-inline' method='get'>")

ngx.say("<label>Date:</label><select name='date' onchange='this.form.submit()'>")
for i = 0, DATE_RANGE_DAYS -1 do
    local d = os.date("%Y%m%d", os.time() - i*86400)
    ngx.say("<option value='"..d.."' "..(d==date and "selected" or "")..">"..d.."</option>")
end
ngx.say("</select>")

ngx.say("<label>Top:</label><input name='top' value='"..tostring(top_n).."' size='4'/>")
ngx.say("<input type='submit' value='Show'/>")
ngx.say("</form><div class='form-inline'><a href='?date="..
        html_escape(date).."&top="..tostring(top_n).."&format=json'>JSON</a></div></div>")

---------------------------------------------------------------------
-- Manage Section
---------------------------------------------------------------------
ngx.say("<div><h3>Manage IP (Whitelist / Blacklist)</h3>")
ngx.say("<div class='small'>注意：動作立即生效，建議用內網或 Nginx auth 保護。</div>")

ngx.say([[
<form method='post' style='margin-top:8px'>
<input type='hidden' name='admin_token' value=']]..html_escape(ADMIN_TOKEN)..[['>
<div class='form-inline'>
IP: <input name='ip' size='15'/>
<select name='action'>
<option value='add_whitelist'>新增白名單</option>
<option value='remove_whitelist'>刪除白名單</option>
<option value='add_blacklist'>新增黑名單</option>
<option value='remove_blacklist'>刪除黑名單</option>
</select>
<input type='submit' value='執行'/>
</div>
</form>
</div>
]])

---------------------------------------------------------------------
-- Table
---------------------------------------------------------------------
ngx.say("<table><tr><th>Domain</th><th>IP</th><th>Count</th><th>Region</th></tr>")
for _, r in ipairs(rows) do
    ngx.say("<tr><td>"..html_escape(r.domain).."</td><td>"..
            html_escape(r.ip).."</td><td>"..tostring(r.count)..
            "</td><td>"..html_escape(r.region or "unknown").."</td></tr>")
end
ngx.say("</table>")

---------------------------------------------------------------------
-- Whitelist
---------------------------------------------------------------------
ngx.say("<div class='ops'><h4>Whitelist</h4><div class='small'>")
ngx.say(table.concat(whitelist_list, ", "))
ngx.say("</div></div>")

---------------------------------------------------------------------
-- Ops Log
---------------------------------------------------------------------
ngx.say("<div class='ops'><h4>Recent Operations</h4><div class='small'>")
for _, l in ipairs(ops) do
    ngx.say(html_escape(cjson.encode(l)) .. "<br/>")
end
ngx.say("</div></div>")

ngx.say("</body></html>")

